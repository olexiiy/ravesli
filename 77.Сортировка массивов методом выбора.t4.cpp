/*Реализуйте следующие два решения оптимизации алгоритма сортировки пузырьком, который вы написали в предыдущем задании:

   Обратите внимание, с каждым выполнением сортировки пузырьком наибольшее значения в массиве «пузырится» до конца. После 
   первой итерации последний элемент массива уже отсортирован. После второй итерации отсортирован предпоследний элемент массива
   и т.д. С каждой новой итерацией нам не нужно перепроверять элементы, которые уже были отсортированы. Измените свой цикл так,
   чтобы не перепроверять элементы, которые уже были отсортированы.
   Если на протяжении всей итерации не выполниться ни одной замены, то мы знаем, что массив уже отсортирован. Внедрите проверку
   того, были ли сделаны какие-либо замены в текущей итерации, и, если нет, завершите выполнение цикла. Если цикл был завершён,
   то выведите информацию о том, на какой итерации сортировка элементов завершилась.
Пример результата выполнения вашей программы:
Early termination on iteration: 8
1 2 3 4 5 6 7 8 9*/

#include <iostream>
#include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>

int main()
{
    const int length(9);
    int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
    int Index=0;

    // Перебираем каждый элемент массива
    // (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберёмся)
    for (int startIndex = 0; startIndex < length - 1; ++startIndex)
    {

        bool swapped(false);
        // Перебираем каждый элемент массива до последнего элемента (не включительно)
        // Последний элемент не имеет пары для сравнения
        for (int currentIndex = 0; currentIndex < (length - startIndex); ++currentIndex)
        {
            // Если текущий элемент больше элемента после него, то меняем их местами
            if (array[currentIndex] > array[currentIndex + 1])
              {  // то запоминаем его
                 std::swap(array[currentIndex], array[currentIndex + 1]);
                 ++Index; // считаем количество общих перестановок
                 swapped = true;
              }
         }
        if (!swapped)
                {
                    // Выполнение начинается с 0-ой итерации, но мы привыкли считать, начиная с 1, поэтому для подсчёта количества итераций добавляем единицу
                    std::cout << "Early termination on iteration: " << startIndex + 1 << '\n';
                    break;
                }
    }
    // Теперь, когда весь массив отсортирован - eвыводим его на экран
    for (int index = 0; index < length; ++index)
        std::cout << array[index] << ' ';
    std::cout << std::endl;
    std:: cout << "the sum of all operation" << Index << std::endl;

    return 0;
}
