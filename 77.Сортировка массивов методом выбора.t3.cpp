/*Это задание уже немного сложнее.

Ещё одним простым методом сортировки элементов является «сортировка пузырьком» (или ещё «пузырьковая сортировка»). Суть
заключается в сравнении пары значений, которые находятся рядом, и, если удовлетворены заданные критерии, значения из этой 
пары меняются местами. И таким образом элементы «скачут пузырьком» до конца массива. Хотя есть несколько способов 
оптимизировать сортировку пузырьком, в этом задании мы будем придерживаться неоптимизированной версии, так как она проще.

При неоптимизированной версии сортировки пузырьком выполняются следующие шаги для сортировки массива от наименьшего до 
наибольшего значения:
   Сравнивается элемент массива под индексом 0 с элементом массива под индексом 1. Если элемент под индексом 0 больше 
   элемента под индексом 1, то значения меняются местами.
   Затем мы перемещаемся к следующей пары значений: элемент под индексом 1 и элемент под индексом 2 и так до тех пор,
   пока не достигнем конца массива.
   Повторяем шаг №1 и шаг №2 до тех пор, пока весь массив не будет отсортирован.
Напишите программу, которая отсортирует следующий массив методом пузырька в соответствии с правилами выше:
const int length(9);
int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };
В конце программы выведите отсортированные элементы массива.
Подсказка: Если мы можем отсортировать только один элемент за одну итерацию, то это означает, что нам нужно будет повторить
выполнение цикла столько раз, сколько есть чисел в нашем массиве (его длина), дабы гарантировать выполнение сортировки всего 
массива.*/


#include <iostream>
#include <algorithm> // для std::swap. В C++11 используйте заголовок <utility>

int main()
{
    const int length(9);
    int array[length] = { 7, 5, 6, 4, 9, 8, 2, 1, 3 };

    // Перебираем каждый элемент массива
    // (кроме последнего, он уже будет отсортирован к тому времени, когда мы до него доберёмся)
    for (int startIndex = 0; startIndex < length - 1; ++startIndex)
    {
        // Перебираем каждый элемент массива до последнего элемента (не включительно)
        // Последний элемент не имеет пары для сравнения
        for (int currentIndex = 0; currentIndex < length - 1; ++currentIndex)
        {
            // Если текущий элемент больше элемента после него, то меняем их местами
            if (array[currentIndex] > array[currentIndex + 1])
                // то запоминаем его
                 std::swap(array[currentIndex], array[currentIndex + 1]);
        }
    }
    // Теперь, когда весь массив отсортирован - выводим его на экран
    for (int index = 0; index < length; ++index)
        std::cout << array[index] << ' ';
    std::cout << std::endl;

    return 0;
}
